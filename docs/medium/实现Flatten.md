---
title: 实现Flatten
---

# {{ $frontmatter.title }}

## 题目描述

在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。

例如:

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]>; // [1, 2, 3, 4, 5]
```

## 分析

这题又回到了元组，flatten 的逻辑本身也比较简单，就是遍历元组，当元素还是元组时，继续递归处理，直到元素非元组结束。

元组的遍历方法可以通过匹配推断：`A extends [infer F, ...infer R]`。

## 题解

```ts
type Flatten<T> =
  // 遍历获取第一个元素
  T extends [infer F, ...infer R]
    ? // 第一个元素是否时元组
      F extends any[]
      ? // 是，那么需要递归处理第一个元素，同时拼接上递归处理后的剩余元素
        [...Flatten<F>, ...Flatten<R>]
      : // 不是，直接返回第一个元素，并拼接上递归处理后的剩余元素
        [F, ...Flatten<R>]
    : // 遍历结束，返回空元组，这样可以保证拼接结果的正确
      [];
```

这里可以注意下 `[...Flatten<F>, ...Flatten<R>]`，因为既需要递归第一个元素，也需要递归剩余元素，还是有一定的圈圈绕。

同时可以留意下最后的 空元组，不理解的可以查看 [实现 Pop](/medium/实现Pop.md) 中提到的边界条件。

## 知识点

1. 元组遍历套路： `T extends [infer F, ...infer R]`
2. 元组遍历边界条件：推断的类型有两个，当入参没有元素时，会走 false 逻辑